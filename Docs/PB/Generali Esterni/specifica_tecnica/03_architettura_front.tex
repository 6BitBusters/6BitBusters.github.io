\section{Descrizione dell'architettura}
\subsection{Architettura frontend}
\subsubsection{Elenco dei componenti}
Poiché il team di sviluppo frontend utilizzerà Redux per la gestione dello stato, l'applicazione sarà strutturata principalmente attraverso la suddivisione del codice in slices, stati iniziali e azioni.
\paragraph{Slices}
    Le Slice contengono una porzione dello stato globale dell’applicazione che è gestita da un reducer
    specifico.
\begin{itemize}
        \item \textbf{DataSlice:} componente che gestisce lo stato e contiene i dati relativi al dataset selezionato dall'utente;
        \item \textbf{DataLabelSlice:} componente che gestisce lo stato e memorizza le etichette associate a ciascun dato del dataset, mantenendo una copia di ogni etichetta;
        \item \textbf{AppStateSlice:} componente che gestisce lo stato dell'applicazione come errori e caricamenti;
        \item \textbf{DataSourceSlice:} componente che gestisce lo stato e contiene l'elenco dei dataset selezionabili dall'utente e il dataset selezionato;
        \item \textbf{FilterOptionSlice:} componente che gestisce lo stato e contiene le opzioni di filtraggio, come la selezione di valori maggiori o minori.;
        \item \textbf{RaycastHitSlice:} componente che gestisce lo stato e contiene le informazioni relative al raycasting.
\end{itemize}
\paragraph{Initial states}
    Gli stati iniziali, definiti all'interno di ciascuna slice, si combinano per formare lo stato globale dell'applicazione, gestito dallo store.
    \begin{itemize}
        \item \textbf{RawDataInitialState:} componente che contiene i dati relativi al dateset selezionato dall'utente;
        \item \textbf{DataLabelInitialState:} componente che contiene i dati relativi alle etichette dei dati del dataset selezionato dall'utente;
        \item \textbf{AppInitialState:} componente che contiene i dati relativi allo stato attuale dell'applicazione;
        \item \textbf{DataSoruceInitialState:} componente che contiene le informazioni principali di tutti i dataset e quelle relative al dataset selezionato dall'utente;
        \item \textbf{FilterOptionInitialState:} componente che contiene i dati relativi alle opzioni di filtraggio selezionate dall'utente;
        \item \textbf{RaycastHitInitialState:} componente che contiene i dati relativi al raycasting, utilizzati per l'interazione con le barre del grafico 3D.
    \end{itemize}
\paragraph{Actions}
    LLe azioni, emesse dai componenti, vengono inviate ai reducers per aggiornare lo stato corrispondente.
    Ogni azione è caratterizzata da un type e da un payload, che viene utilizzato dalle slices per modificare lo stato.
    Per convenzione il nome delle azioni segue il formato: \\
    \begin{center}
        \textbf{[nome Slice dalla quale viene catturata].[nome azione]}.
    \end{center}
    \begin{itemize}
        \item \textbf{DataSlice.RequestData:} azione asincrona emessa per recuperare, dal server, i dati del dataset selezionato; \\ Payload: nessuno
        \item \textbf{DataSlice.FilterTopN:} azione emessa per filtrare i dati, visualizzando esclusivamente i top o bottom N valori; \\ Payload: FilterPayload
        \item \textbf{DataSlice.FilterAboveValue:} azione emessa per filtrare i dati, visualizzando esclusivamente quelli con un valore maggiore o minore rispetto al valore selezionato;\\ Payload: FilterPayload
        \item \textbf{DataSlice.FilterAverage:} azione emessa per filtrare i dati, visualizzando esclusivamente quelli con un valore maggiore o minore rispetto alla media globale; \\ Payload: boolean $\rightarrow$ maggiore o minore
        \item \textbf{DataLabelSlice.SetDataLabel:} azione emessa per inizializzare le etichette dei dati; \\ Payload: DataLabel.
        \item \textbf{AppStateSlice.SetLoading:} azione emessa per aggiornare lo stato dell'applicazione e visualizzare la pagina di caricamento; \\ Payload: boolean
        \item \textbf{AppStateSlice.SetError:} azione emessa per aggiornare lo stato dell'applicazione e visualizzare una schermata di errore specifica, basata sull'errore generato dall'applicazione; \\ Payload: number $\rightarrow$ codice di errore.
        \item \textbf{DataSourceSlice.RequestDatasets:} azione asincrona emessa per recuperare l'elenco delle informazioni relative a tutti i dataset disponibili; \\ Payload: nessuno.
        \item \textbf{DataSourceSlice.SetCurrentDataset:} azione emessa per aggiornare il dataset selezionato dall'utente; \\ Payload: string DatasetInfo.
        \item \textbf{FilterOptionSlice.ToggleAveragePlane:} azione emessa per aggiornare il flag di visibilità del piano medio globale nell'ambiente 3D; \\ Payload: boolean 
        \item \textbf{FilterOptionSlice.ToggleIsGreater:} azione emessa per aggiornare il flag che determina se il filtraggio deve essere eseguito per valori maggiori o minori; \\ Payload: boolean
        \item \textbf{RaycastHitSlice.SetHit:} azione emessa per aggiornare la barra selezionata nel grafico 3D; \\ Payload: number $\rightarrow$ ID della barra.
        \item \textbf{RaycastHitSlice.SetTooltipPosition:} azione emessa per aggiornare la posizione del tooltip in base alla posizione del puntatore.\\ Payload: Vector3 $\rightarrow$ posizione del puntatore.
    \end{itemize}
\paragraph{Classes}
    Classi offerte dalle librerie utilizzate:
    \begin{itemize}
        \item \textbf{Vector3:} classe offerta dalla libreria three.js. Rappresenta un vettore tridimensionale, ovvero
        una grandezza fisica caratterizzata da una direzione e da una lunghezza. Il vettore tridimensionale
        viene comunemente utilizzato per definire la posizione, la rotazione, la scala e la direzione
        delle barre del grafico 3D;
        \item \textbf{Provider:} Componente Redux che rende lo store accessibile a tutti i componenti dell'applicazione, "avvolgendo" il componente principale App e accettando lo store come prop;
        \item \textbf{Store:} Lo store Redux traccia lo stato dell'applicazione, contiene il reducer principale per la gestione delle azioni e fornisce metodi per accedere allo stato,
        inviare azioni e registrare listener per le modifiche di stato;
        \item \textbf{RootReducer:} componente Redux che combina tutti i reducers dell’applicazione in uno stato
        globale. Questa funzione viene passata allo store per gestire lo stato complessivo dell’applicazione;
        \item \textbf{FontLoader:} classe utility di Three.js che permette di caricare dati di font in formato JSON per poi generare mesh di testo in ambienti tridimensionali;
        \item \textbf{Gasp:} classe utility della libreria gasp che permette di creare animazioni sia dell'interfaccia utente e sia all'interno dell'ambiente 3D con facilità e poco codice.
    \end{itemize}
    Classi definite dal team:
    \begin{itemize}
        \item \textbf{RawData:} classe che rappresenta un singolo dato, visualizzato come una barra nel grafico;
        \item \textbf{DataLabel:} classe che contiene array di etichette, uno per l'asse x e uno per l'asse z;
        \item \textbf{AppState:} classe che rappresenta lo stato globale dell'applicazione;
        \item \textbf{DatasetInfo:} classe che rappresenta un dataset e ne memorizza le informazioni principali;
        \item \textbf{FilterOption:} classe che rappresenta la configurazione delle opzioni di filtraggio dati;
        \item \textbf{RaycastHit:} classe che rappresenta il punto di intersezione tra il puntatore e la barra del grafico;
        \item \textbf{FilterPayload:} classe che rappresenta il payload da inviare alle azioni di filtraggio del DataSlice;
        \item \textbf{MaxRequestError:} classe che rappresenta un errore di superamento del limite massimo di richieste effettuate;
        \item \textbf{NetworkError:} classe che rappresenta un errore di comunicazione e connessione alle API;
        \item \textbf{ServerError:} classe che rappresenta un errore di connessione al server.
    \end{itemize}
\paragraph{React UI components}
    I seguenti componenti, sviluppati dal team, visualizzano i dati dello stato che compongono l'interfaccia utente:
    \begin{itemize}
        \item \textbf{RouterErrorPage:} componente che visualizza la pagina di errore dell'applicazione web;
        \item \textbf{SelectionPage:} componente che visualizza la homepage dell'applicazione web;
        \item \textbf{DatasetItem:} componente che visualizza un singolo dataset con i relativi dati.
        \item \textbf{UI:} componente che aggrega i componenti grafici che compongono l'interfaccia utente;
                \item \textbf{Tooltip:} componente che visualizza un tooltip con i dettagli di una barra;
        \item \textbf{DataTable:} componente che visualizza una tabella contenente tutti i valori del dataset selezionato;
        \item \textbf{FilterModOption:} componente per la configurazione del tipo di filtraggio dati;
        \item \textbf{AvgPlaneOption:} componente per la selezione della visibilità del piano medio;
        \item \textbf{NFilter:} componente che consente l'inserimento di un valore N e applica il filtraggio ai primi o agli ultimi N valori;
        \item \textbf{AbsFilter:} componente che consente di filtrare i valori maggiori o minori rispetto alla media globale;
        \item \textbf{AboveFilter:} componente che consente di filtrare i valori maggiori o minori rispetto al valore selezionato dall'utente;
        \item \textbf{BaseFilter:} componente contenente gli elementi comuni a tutti i componenti di filtraggio.
    \end{itemize}
\paragraph{Three.js 3D components}
    I seguenti componenti visualizzano i dati del dataset all'interno dell'ambiente 3D tramite un grafico.
    \begin{itemize}
        \item \textbf{MainEnvironment:} componente che visualizza la pagina in cui viene renderizzato l'ambiente 3D;
        \item \textbf{CustomCanvas:} componente che fornisce una camera e una scena 3D, configurabili tramite props opzionali;
        \item \textbf{BarChart:} componente che visualizza un grafico tridimensionale;
        \item \textbf{Bar:} componente che visualizza una singola barra in un grafico tridimensionale;
        \item \textbf{ZAxis:} componente che rappresenta l'asse Z del grafico tridimensionale;
        \item \textbf{XAxis:} componente che rappresenta l'asse X del grafico tridimensionale;
        \item \textbf{YAxis:} componente che rappresenta l'asse Y del grafico tridimensionale;
        \item \textbf{Lights:} componente che gestisce l'illuminazione all'interno della scena 3D.
    \end{itemize}

\subsection{Design pattern architetturale}
I componenti che costituiscono l’architettura utilizzata seguono il pattern offerto dalla libreria Redux-
Toolkit.
Redux-Toolkit è pensato per integrarsi con React e il principale vantaggio che offre è quello di poter
gestire i dati condivisi tra i componenti React in modo centralizzato semplificando la gestione dello stato
globale dell’applicazione.
Inoltre Redux-Toolkit è un wrapper che semplifica l'utilizzo di Redux in modo tale da scrivere meno codice e commettere meno errori durante lo sviluppo.

I componenti che formano l’architettura di Redux-Toolkit sono:
\begin{itemize}
    \item \textbf{Store:} componente che contiene lo stato globale dell’applicazione.
    All’avvio dell’applicazione viene configurato utilizzando RootReducer e i componenti che utilizzano
    lo stato globale si mettono in ascolto dello store in modo da venire renderizzati ogni volta che un dato
    di interesse cambia valore. Questo modo di operare può essere visto come un pattern Observer in
    cui lo store è il Subject e gli Observers sono i componenti React che osservano i cambiamenti dello store;
    \item \textbf{RootReducer:} componente utilizzato per configurare lo store combinando le slice;
    \item \textbf{Slice:} componente che contiene un proprio stato che rappresenta una porzione dello stato globale
    dell’applicazione, i reducer che operano su tale stato e i selector per consentire ai suoi client il
    reperimento dei dati;
    \item \textbf{Reducer:} componente che riceve come parametri uno stato iniziale (InitialState) e una action
    (composta da un type e un payload) e restituisce lo stato dopo aver operato sui dati. 
    React-Toolkit gestisce le chiamate ai reducer in seguito ai dispatch delle action che avvengono
    specificando solamente l’oggetto che rappresenta il payload;
    \item \textbf{Actions:} oggetto composto da un type e da un payload di cui viene effettuato il dispatch quando
    opportuno. Il payload è un oggetto che contiene i dati da passare al reducer che catturerà l’action;
    \item \textbf{InitialState:}componente che contiene i dati di una slice su cui essa opera.
    Importante sottolineare che Redux-Toolkit garantisce anche l’immutabilità
    dei dati in modo che i reducer restituiscano delle copie dello stato in modo che esso non possa venire
    modificato dall’esterno e utilizzato in modo improrio.
    L’unico modo per modificare i dati dello stato globale `e quindi con il dispatch di un’action;
    \item \textbf{Selector:} funzione che prende lo stato corrente di una slice come argomento e ritorna un sottoinsieme
    specifico del suo stato. In altre parole, un selector consente di selezionare una parte specifica
    dello stato in modo da poterla utilizzare in modo isolato all’interno di un componente React.
\end{itemize}

\subsection{Architettura logica}
